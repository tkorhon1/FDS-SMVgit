
! ------------ module COMPLEX_GEOMETRY ---------------------------------

MODULE COMPLEX_GEOMETRY ! this module will be moved to FDS

USE PRECISION_PARAMETERS
USE COMP_FUNCTIONS, ONLY: CHECKREAD,SHUTDOWN
USE MEMORY_FUNCTIONS, ONLY: ChkMemErr
USE READ_INPUT, ONLY: GET_SURF_INDEX
USE GLOBAL_CONSTANTS
USE TYPES

IMPLICIT NONE
REAL(EB), PARAMETER :: DEG2RAD=4.0_EB*ATAN(1.0_EB)/180.0_EB

PRIVATE
PUBLIC :: READ_GEOM,WRITE_GEOM,ROTATE_VEC, SETUP_TRANSFORM, OBST2GEOM
 
CONTAINS

! ------------ SUBROUTINE READ_GEOM ---------------------------------

SUBROUTINE READ_GEOM

! input &GEOM lines

INTEGER, PARAMETER :: MAX_VERTS=100000 ! at some point we may decide to use dynmaic memory allocation
INTEGER, PARAMETER :: MAX_FACES=MAX_VERTS
INTEGER, PARAMETER :: MAX_IDS=100000
CHARACTER(30) :: ID,SURF_ID, GEOM_IDS(MAX_IDS)
CHARACTER(30) :: TEXTURE_MAPPING
REAL(EB) :: DAZIM(MAX_IDS), DELEV(MAX_IDS), DSCALE(3,MAX_IDS), DXYZ0(3,MAX_IDS), DXYZ(3,MAX_IDS)
REAL(EB) :: AZIM, ELEV, SCALE(3), XYZ0(3), XYZ(3)
REAL(EB) :: AZIM_DOT, ELEV_DOT, SCALE_DOT(3), XYZ_DOT(3)
REAL(EB) :: GROTATE, GROTATE_DOT, GAXIS(3)
REAL(EB), PARAMETER :: MAX_COORD=1.0E20_EB
REAL(EB) :: VERTS(3*MAX_VERTS)
REAL(EB) :: TEXTURE_ORIGIN(3), TEXTURE_SCALE(2)
INTEGER :: FACES(3*MAX_FACES)
INTEGER :: N_VERTS, N_FACES
INTEGER :: SURF_INDEX
INTEGER :: IOS,IZERO,N, I, NSUB_GEOMS, GEOM_INDEX
LOGICAL COMPONENT_ONLY
LOGICAL, ALLOCATABLE, DIMENSION(:) :: DEFAULT_COMPONENT_ONLY
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL(), GSUB=>NULL()
NAMELIST /GEOM/ AZIM, AZIM_DOT, COMPONENT_ONLY, DAZIM, DELEV, DSCALE, DXYZ0, DXYZ, &
                ELEV, ELEV_DOT, FACES, GAXIS, GROTATE, GROTATE_DOT,GEOM_IDS, ID, SCALE, &
                SCALE_DOT, SURF_ID, TEXTURE_ORIGIN, TEXTURE_SCALE, TEXTURE_MAPPING,&
                VERTS, XYZ0, XYZ, XYZ_DOT

! count &GEOM lines

N_GEOMETRY=0
IS_GEOMETRY_DYNAMIC = .FALSE.
REWIND(LU_INPUT)
COUNT_GEOM_LOOP: DO
   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT COUNT_GEOM_LOOP
   READ(LU_INPUT,NML=GEOM,END=11,ERR=12,IOSTAT=IOS)
   N_GEOMETRY=N_GEOMETRY+1
   12 IF (IOS>0) CALL SHUTDOWN('ERROR: problem with GEOM line')
ENDDO COUNT_GEOM_LOOP
11 REWIND(LU_INPUT)

IF (N_GEOMETRY==0) RETURN

! Allocate GEOMETRY array

ALLOCATE(GEOMETRY(0:N_GEOMETRY),STAT=IZERO)
CALL ChkMemErr('READ','GEOMETRY',IZERO)

ALLOCATE(DEFAULT_COMPONENT_ONLY(N_GEOMETRY),STAT=IZERO)
CALL ChkMemErr('READ','DEFAULT_COMPONENT_ONLY',IZERO)

! set default for COMPONENT_ONLY
!   if an object is in a GEOM_IDS list then COMPONENT_ONLY for this object is initially 
!       set to .TRUE. (is only drawn as part of a larger group)
!   if an object is not in any GEOM_IDS list then COMPONENT_ONLY for this object is initially 
!       set to .FALSE. (is drawn by default)
READ_GEOM_LOOP0: DO N=1,N_GEOMETRY
   G=>GEOMETRY(N)
   
   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT READ_GEOM_LOOP0
   
   ! Set defaults
   
   GEOM_IDS = ''

   ! Read the GEOM line
   
   READ(LU_INPUT,GEOM,END=25)

   DEFAULT_COMPONENT_ONLY(N) = .FALSE.
   DO I = 1, MAX_IDS
      IF (GEOM_IDS(I)=='') EXIT
      IF (N.GT.1) THEN
         GEOM_INDEX = GET_GEOM_ID(GEOM_IDS(I),N-1)
         IF (GEOM_INDEX.GE.1.AND.GEOM_INDEX.LE.N-1) THEN
            DEFAULT_COMPONENT_ONLY(GEOM_INDEX) = .TRUE.
         ENDIF
      ENDIF
   END DO
   
ENDDO READ_GEOM_LOOP0
25 REWIND(LU_INPUT)

! read GEOM data

READ_GEOM_LOOP: DO N=1,N_GEOMETRY
   G=>GEOMETRY(N)
   
   CALL CHECKREAD('GEOM',LU_INPUT,IOS)
   IF (IOS==1) EXIT READ_GEOM_LOOP
   
   ! Set defaults
   
   COMPONENT_ONLY=DEFAULT_COMPONENT_ONLY(N)
   ID = 'geom'
   SURF_ID = 'null'
   TEXTURE_ORIGIN = 0.0_EB
   TEXTURE_MAPPING = 'RECTANGULAR'
   TEXTURE_SCALE = 1.0_EB
   VERTS=1.001_EB*MAX_COORD
   FACES=0
   GEOM_IDS = ''
   
   AZIM = 0.0_EB
   ELEV = 0.0_EB
   SCALE = 1.0_EB
   XYZ0 = 0.0_EB
   XYZ = 0.0_EB
   
   AZIM_DOT = 0.0_EB
   ELEV_DOT = 0.0_EB
   SCALE_DOT = 0.0_EB
   XYZ_DOT = 0.0_EB

   DAZIM = 0.0_EB
   DELEV = 0.0_EB
   DSCALE = 1.0_EB
   DXYZ0 = 0.0_EB
   DXYZ = 0.0_EB
   
   GAXIS(1) = 1.001_EB*MAX_COORD
   GAXIS(2) = 1.001_EB*MAX_COORD
   GAXIS(3) = 1.001_EB*MAX_COORD
   GROTATE = 1.001_EB*MAX_COORD
   GROTATE_DOT = 1.001_EB*MAX_COORD

   ! Read the GEOM line
   
   READ(LU_INPUT,GEOM,END=35)
   
   N_VERTS=0
   DO I = 1, MAX_VERTS
      IF (VERTS(3*I-2).GE.MAX_COORD.OR.VERTS(3*I-1).GE.MAX_COORD.OR.VERTS(3*I).GE.MAX_COORD) EXIT
      N_VERTS=N_VERTS+1
   END DO
   
   N_FACES=0
   DO I = 1, MAX_FACES
      IF (FACES(3*I-2).EQ.0.OR.FACES(3*I-1).EQ.0.OR.FACES(3*I).EQ.0) EXIT
      N_FACES=N_FACES+1
   END DO

   G%COMPONENT_ONLY=COMPONENT_ONLY
   
   NSUB_GEOMS=0
   DO I = 1, MAX_IDS
      IF (GEOM_IDS(I)=='') EXIT
      NSUB_GEOMS=NSUB_GEOMS+1
   END DO
   IF (NSUB_GEOMS.GT.0) THEN
      ALLOCATE(G%SUB_GEOMS(NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','SUB_GEOMS',IZERO)
      
      ALLOCATE(G%DSCALE(3,NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','DSCALE',IZERO)
      
      ALLOCATE(G%DAZIM(NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','DAZIM',IZERO)
      
      ALLOCATE(G%DELEV(NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','DELEV',IZERO)
      
      ALLOCATE(G%DXYZ0(3,NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','DXYZ0',IZERO)
      
      ALLOCATE(G%DXYZ(3,NSUB_GEOMS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','DXYZ',IZERO)

      N_FACES=0 ! ignore vertex and face entries if there are any GEOM_IDS
      N_VERTS=0
   ENDIF
   G%NSUB_GEOMS=NSUB_GEOMS
   
   G%ID = ID
   G%N_FACES_BASE = N_FACES
   G%N_VERTS_BASE = N_VERTS
   G%HAS_SURF = .TRUE.
   G%HAS_TEXTURE = 0
   G%TEXTURE_ORIGIN = TEXTURE_ORIGIN
   G%TEXTURE_SCALE = TEXTURE_SCALE
   IF ( TRIM(TEXTURE_MAPPING).NE.'SPHERICAL'.AND.TRIM(TEXTURE_MAPPING).NE.'RECTANGULAR') TEXTURE_MAPPING = 'RECTANGULAR'
   G%TEXTURE_MAPPING = TEXTURE_MAPPING
   IF (SURF_ID.EQ.'null') THEN
      G%HAS_SURF = .FALSE.
      SURF_ID = 'INERT'
   ENDIF
   G%SURF_ID = SURF_ID

   IF (N_FACES.GT.0) THEN
      ALLOCATE(G%FACES(3*N_FACES),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','FACES',IZERO)
      G%FACES(1:3*N_FACES) = FACES(1:3*N_FACES)
      
      DO I = 1, 3*N_FACES
         IF (FACES(I).LT.1.OR.FACES(I).GT.N_VERTS) THEN
            CALL SHUTDOWN('ERROR: problem with GEOM, vertex index out of bounds')
         ENDIF
      END DO

      ALLOCATE(G%SURFS(N_FACES),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','SURFS',IZERO)
      SURF_INDEX = GET_SURF_INDEX(SURF_ID)
      G%SURFS(1:N_FACES) = SURF_INDEX
   ENDIF

   IF (N_VERTS.GT.0) THEN
      ALLOCATE(G%VERTS_BASE(3*N_VERTS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','VERTS',IZERO)
      G%VERTS_BASE(1:3*N_VERTS) = VERTS(1:3*N_VERTS)

      ALLOCATE(G%VERTS(3*N_VERTS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','VERTS',IZERO)

      ALLOCATE(G%TVERTS(2*N_VERTS),STAT=IZERO)
      CALL ChkMemErr('READ_GEOM','TVERTS',IZERO)
   ENDIF
   
   DO I = 1, NSUB_GEOMS
      GEOM_INDEX = GET_GEOM_ID(GEOM_IDS(I),N-1)
      IF (GEOM_INDEX.GE.1.AND.GEOM_INDEX.LE.N-1) THEN
         G%SUB_GEOMS(I)=GEOM_INDEX
      ELSE
         CALL SHUTDOWN('ERROR: problem with GEOM '//TRIM(G%ID)//' line, '//TRIM(GEOM_IDS(I))//' not yet defined.')
      ENDIF
   END DO
   
! use GROTATE/GAXIS or AZIM/ELEV but not both

   IF(ANY(GAXIS(1:3).LT.MAX_COORD).OR.GROTATE.LT.MAX_COORD.OR.GROTATE_DOT.LT.MAX_COORD)THEN
      IF(GAXIS(1).GT.MAX_COORD) GAXIS(1) = 0.0_EB
      IF(GAXIS(2).GT.MAX_COORD) GAXIS(2) = 0.0_EB
      IF(GAXIS(3).GT.MAX_COORD) GAXIS(3) = 0.0_EB
      AZIM = 0.0_EB
      ELEV = 0.0_EB
      AZIM_DOT = 0.0_EB
      ELEV_DOT = 0.0_EB
      
      IF(GROTATE.GT.MAX_COORD) GROTATE = 0.0_EB
      IF(GROTATE_DOT.GT.MAX_COORD) GROTATE_DOT = 0.0_EB
      
      IF(ALL(ABS(GAXIS(1:3)).LT.TWO_EPSILON_EB))THEN
         GAXIS(1) = 0.0_EB
         GAXIS(2) = 0.0_EB
         GAXIS(3) = 1.0_EB
      ELSE
         GAXIS = GAXIS/SQRT(DOT_PRODUCT(GAXIS,GAXIS))
      ENDIF
   ELSE
      GAXIS(1) = 0.0_EB
      GAXIS(2) = 0.0_EB
      GAXIS(3) = 1.0_EB
      GROTATE = 0.0_EB
      GROTATE_DOT = 0.0_EB
   ENDIF
   
   G%XYZ0(1:3) = XYZ0(1:3)
   
   G%GAXIS = GAXIS
   G%GROTATE = GROTATE
   G%GROTATE_BASE = GROTATE
   G%GROTATE_DOT = GROTATE_DOT

   G%AZIM_BASE = AZIM
   G%AZIM_DOT = AZIM_DOT
   
   G%ELEV_BASE = ELEV
   G%ELEV_DOT = ELEV_DOT

   G%SCALE_BASE = SCALE
   G%SCALE_DOT(1:3) = SCALE_DOT(1:3)

   G%XYZ_BASE(1:3) = XYZ(1:3)
   G%XYZ_DOT(1:3) = XYZ_DOT(1:3)

   IF (ABS(AZIM_DOT).GT.TWO_EPSILON_EB .OR. ABS(ELEV_DOT).GT.TWO_EPSILON_EB.OR.&
       ANY(ABS(SCALE_DOT(1:3)).GT.TWO_EPSILON_EB) .OR. ANY(ABS(XYZ_DOT(1:3) ).GT.TWO_EPSILON_EB) ) THEN 
      G%IS_DYNAMIC = .TRUE.
      IS_GEOMETRY_DYNAMIC = .TRUE.
   ELSE
      G%IS_DYNAMIC = .FALSE.
   ENDIF

   IF (NSUB_GEOMS.GT.0) THEN   

   ! if any component of a group is time dependent then the whole group is time dependent

      DO I = 1, NSUB_GEOMS
         GSUB=>GEOMETRY(G%SUB_GEOMS(I))

         IF (GSUB%IS_DYNAMIC) THEN
            G%IS_DYNAMIC = .TRUE.
            IS_GEOMETRY_DYNAMIC = .TRUE.
            EXIT
         ENDIF
      END DO
      
      G%DXYZ0(1:3,1:NSUB_GEOMS) = DXYZ0(1:3,1:NSUB_GEOMS)

      G%DAZIM(1:NSUB_GEOMS) = DAZIM(1:NSUB_GEOMS)
      G%DELEV(1:NSUB_GEOMS) = DELEV(1:NSUB_GEOMS)
      G%DSCALE(1:3,1:NSUB_GEOMS) = DSCALE(1:3,1:NSUB_GEOMS)
      G%DXYZ(1:3,1:NSUB_GEOMS) =  DXYZ(1:3,1:NSUB_GEOMS)

! allocate memory for vertex and face arrays for GEOMs that contain groups (entres in GEOM_IDs )

      DO I = 1, NSUB_GEOMS
         GSUB=>GEOMETRY(G%SUB_GEOMS(I))
         G%N_FACES_BASE = G%N_FACES_BASE + GSUB%N_FACES_BASE
         G%N_VERTS_BASE = G%N_VERTS_BASE + GSUB%N_VERTS_BASE
      END DO

      IF (G%N_FACES_BASE.GT.0) THEN
         ALLOCATE(G%FACES(3*G%N_FACES_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','FACES',IZERO)
      
         ALLOCATE(G%SURFS(G%N_FACES_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','SURFS',IZERO)
      ENDIF

      IF (G%N_VERTS_BASE.GT.0) THEN
         ALLOCATE(G%VERTS_BASE(3*G%N_VERTS_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','VERTS',IZERO)

         ALLOCATE(G%VERTS(3*G%N_VERTS_BASE),STAT=IZERO)
         CALL ChkMemErr('READ_GEOM','VERTS',IZERO)
      ENDIF
   ENDIF
ENDDO READ_GEOM_LOOP
35 REWIND(LU_INPUT)

DEALLOCATE(DEFAULT_COMPONENT_ONLY)
END SUBROUTINE READ_GEOM

! ------------ INTEGER FUNCTION GET_GEOM_ID ---------------------------------

INTEGER FUNCTION GET_GEOM_ID(ID,N_LAST)

! return the index of the geometry array with label ID

CHARACTER(30), INTENT(IN) :: ID
INTEGER, INTENT(IN) :: N_LAST
INTEGER :: N
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
   
GET_GEOM_ID=0
DO N=1,N_LAST
   G=>GEOMETRY(N)
   IF (TRIM(G%ID)==TRIM(ID)) THEN
      GET_GEOM_ID=N
      RETURN
   ENDIF
END DO
END FUNCTION GET_GEOM_ID

! ------------ SUBROUTINE SETUP_TRANSFORM ---------------------------------

SUBROUTINE SETUP_TRANSFORM(SCALE,AZ,ELEV,GAXIS,GROTATE,M)

! construct a rotation matrix M that rotates a vector by
! AZ degrees around the Z axis then ELEV degrees around
! the (cos AZ, sin AZ, 0) axis

REAL(EB), INTENT(IN) :: SCALE(3), AZ, ELEV, GAXIS(3), GROTATE
REAL(EB), DIMENSION(3,3), INTENT(OUT) :: M

REAL(EB) :: AXIS(3), M0(3,3), M1(3,3), M2(3,3), M3(3,3), MTEMP(3,3), MTEMP2(3,3)

M0 = RESHAPE ((/&
               SCALE(1),  0.0_EB, 0.0_EB,&
                 0.0_EB,SCALE(2), 0.0_EB,&
                 0.0_EB,  0.0_EB,SCALE(3) &
               /),(/3,3/))

AXIS = (/0.0_EB, 0.0_EB, 1.0_EB/)
CALL SETUP_ROTATE(AZ,AXIS,M1)

AXIS = (/COS(DEG2RAD*AZ), SIN(DEG2RAD*AZ), 0.0_EB/)
CALL SETUP_ROTATE(ELEV,AXIS,M2)

CALL SETUP_ROTATE(GROTATE,GAXIS,M3)

MTEMP = MATMUL(M1,M0)
MTEMP2 = MATMUL(M2,MTEMP)
M = MATMUL(M3,MTEMP2)
END SUBROUTINE SETUP_TRANSFORM

! ------------ SUBROUTINE SETUP_ROTATE ---------------------------------

SUBROUTINE SETUP_ROTATE(ALPHA,U,M)

! construct a rotation matrix M that rotates a vector by
! ALPHA degrees about an axis U

REAL(EB), INTENT(IN) :: ALPHA, U(3)
REAL(EB), INTENT(OUT) :: M(3,3)
REAL(EB) :: UP(3,1), S(3,3), UUT(3,3), IDENTITY(3,3)

UP = RESHAPE(U/SQRT(DOT_PRODUCT(U,U)),(/3,1/))
S =   RESHAPE( (/&
                   0.0_EB, -UP(3,1),  UP(2,1),&
                  UP(3,1),   0.0_EB, -UP(1,1),&
                 -UP(2,1),  UP(1,1),  0.0_EB  &
                 /),(/3,3/))
UUT = MATMUL(UP,TRANSPOSE(UP))
IDENTITY = RESHAPE ((/&
               1.0_EB,0.0_EB,0.0_EB,&
               0.0_EB,1.0_EB,0.0_EB,&
               0.0_EB,0.0_EB,1.0_EB &
               /),(/3,3/))
M = UUT + COS(ALPHA*DEG2RAD)*(IDENTITY - UUT) + SIN(ALPHA*DEG2RAD)*S
END SUBROUTINE SETUP_ROTATE

! ------------ SUBROUTINE TRANSLATE_VEC ---------------------------------

SUBROUTINE TRANSLATE_VEC(XYZ,N,XIN,XOUT)

! translate a geometry by the vector XYZ

INTEGER, INTENT(IN) :: N
REAL(EB), INTENT(IN) :: XYZ(3), XIN(3*N)
REAL(EB), INTENT(OUT) :: XOUT(3*N)
REAL(EB) :: VEC(3)
INTEGER :: I

DO I = 1, N 
   VEC(1:3) = XYZ(1:3) + XIN(3*I-2:3*I) ! copy into a temp array so XIN and XOUT can point to same space
   XOUT(3*I-2:3*I) = VEC(1:3)
END DO
END SUBROUTINE TRANSLATE_VEC

! ------------ SUBROUTINE ROTATE_VEC ---------------------------------

SUBROUTINE ROTATE_VEC(M,N,XYZ0,XIN,XOUT)

! rotate the vector XIN about the origin XYZ0

INTEGER, INTENT(IN) :: N
REAL(EB), INTENT(IN) :: M(3,3), XIN(3*N), XYZ0(3)
REAL(EB), INTENT(OUT) :: XOUT(3*N)
REAL(EB) :: VEC(3)
INTEGER :: I

DO I = 1, N
   VEC(1:3) = MATMUL(M,XIN(3*I-2:3*I)-XYZ0(1:3))  ! copy into a temp array so XIN and XOUT can point to same space
   XOUT(3*I-2:3*I) = VEC(1:3) + XYZ0(1:3)
END DO
END SUBROUTINE ROTATE_VEC

! ------------ SUBROUTINE PROCESS_GEOMS ---------------------------------

SUBROUTINE PROCESS_GEOM(IS_DYNAMIC,TIME)

! transform (scale, rotate and translate) vectors found on each &GEOM line

   LOGICAL, INTENT(IN) :: IS_DYNAMIC
   REAL(EB), INTENT(IN) :: TIME
   INTEGER :: I
   TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
   REAL(EB) :: M(3,3), DELTA_T
   
   IF (IS_DYNAMIC) THEN
      DELTA_T = TIME - T_BEGIN
   ELSE
      DELTA_T = 0.0_EB
   ENDIF
   
   DO I = 0, N_GEOMETRY
      G=>GEOMETRY(I)

      G%SCALE = G%SCALE_BASE + DELTA_T*G%SCALE_DOT
      G%AZIM = G%AZIM_BASE + DELTA_T*G%AZIM_DOT
      G%ELEV = G%ELEV_BASE + DELTA_T*G%ELEV_DOT
      G%XYZ = G%XYZ_BASE + DELTA_T*G%XYZ_DOT
      G%GROTATE = G%GROTATE_BASE + DELTA_T*G%GROTATE_DOT
      
      IF (IS_DYNAMIC.AND.G%IS_DYNAMIC.OR..NOT.IS_DYNAMIC.AND..NOT.G%IS_DYNAMIC) THEN
         G%N_VERTS = G%N_VERTS_BASE
         G%N_FACES = G%N_FACES_BASE
      ELSE
         G%N_VERTS = 0
         G%N_FACES = 0
      ENDIF
   END DO
   
   DO I = 0, N_GEOMETRY
      G=>GEOMETRY(I)

      IF (G%NSUB_GEOMS>0) CALL EXPAND_GROUPS(I) ! create vertex and face list from geometries specified in GEOM_IDS list
      IF (G%N_VERTS.EQ.0) CYCLE
      CALL SETUP_TRANSFORM(G%SCALE,G%AZIM,G%ELEV,G%GAXIS,G%GROTATE,M)
      CALL ROTATE_VEC(M,G%N_VERTS,G%XYZ0,G%VERTS_BASE,G%VERTS)
      CALL TRANSLATE_VEC(G%XYZ,G%N_VERTS,G%VERTS,G%VERTS)
   END DO
   !CALL GEOM2TEXTURE
END SUBROUTINE PROCESS_GEOM

! ------------ SUBROUTINE GEOM2TEXTURE ---------------------------------

SUBROUTINE GEOM2TEXTURE
   INTEGER :: I,J
   TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
   REAL(EB), POINTER, DIMENSION(:) :: XYZ, TXYZ
   REAL(EB) :: DXYZ(3), AZ, ELEV, XYNORM
   REAL, PARAMETER :: PI=4.0*ATAN(1.0_EB)
   INTEGER :: SURF_INDEX
   TYPE(SURFACE_TYPE), POINTER :: SF=>NULL()
   
   DO I = 0, N_GEOMETRY
      G=>GEOMETRY(I)
      
      IF(G%NSUB_GEOMS .NE. 0) CYCLE
      IF(G%TEXTURE_MAPPING .EQ. 'RECTANGULAR') THEN
         DO J = 1, G%N_VERTS
            SURF_INDEX = G%SURFS(J)
            SF=>SURFACE(SURF_INDEX)
            IF (TRIM(SF%TEXTURE_MAP).EQ.'null') CYCLE
            
            XYZ(1:3) => G%VERTS(3*J-2:3*J)
            TXYZ(1:2) => G%TVERTS(2*J-1:2*J)
            TXYZ(1:2) = (XYZ(1:2) - G%TEXTURE_ORIGIN(1:2))/G%TEXTURE_SCALE(1:2)
         END DO
      ELSE
         DO J = 1, G%N_VERTS
            SURF_INDEX = G%SURFS(J)
            SF=>SURFACE(SURF_INDEX)
            IF (TRIM(SF%TEXTURE_MAP).EQ.'null') CYCLE
            
            XYZ(1:3) => G%VERTS(3*J-2:3*J)
            TXYZ(1:2) => G%TVERTS(2*J-1:2*J)
            DXYZ = XYZ - G%TEXTURE_ORIGIN
            XYNORM = SQRT(DXYZ(1)*DXYZ(1)+DXYZ(2)*DXYZ(2))
            AZ = ATAN2(DXYZ(2),DXYZ(1))  ! ranges from -PI to +PI
            ELEV = ATAN2(DXYZ(3),XYNORM) ! ranges from -PI/2 to +PI/2 (since XYNORM>=0)
            TXYZ(1) = (AZ + PI)/(2.0_EB*PI) ! scale from (-PI,PI) to (0.0,1.0)
            TXYZ(2) = (ELEV + PI/2.0_EB)/PI ! scale from (-PI/2,PI/2) to (0.0,1.0)
         END DO
      ENDIF
   END DO
END SUBROUTINE GEOM2TEXTURE

! ------------ SUBROUTINE MERGE_GEOMS ---------------------------------

SUBROUTINE MERGE_GEOMS(VERTS,N_VERTS,FACES,SURF_IDS,N_FACES,IS_DYNAMIC)

! combine vectors and faces found on all &GEOM lines into one set of VECTOR and FACE arrays

INTEGER, INTENT(IN) :: N_VERTS, N_FACES
LOGICAL, INTENT(IN) :: IS_DYNAMIC
INTEGER :: I
INTEGER, DIMENSION(:) :: FACES(3*N_FACES), SURF_IDS(N_FACES)
REAL(EB), DIMENSION(:) :: VERTS(3*N_VERTS)
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
INTEGER :: IVERT, IFACE, ISURF, OFFSET
   
IVERT = 0
IFACE = 0
ISURF = 0
OFFSET = 0
DO I = 0, N_GEOMETRY
   G=>GEOMETRY(I)
   IF (G%COMPONENT_ONLY) CYCLE
   IF (G%IS_DYNAMIC.AND..NOT.IS_DYNAMIC) CYCLE
   IF (.NOT.G%IS_DYNAMIC.AND.IS_DYNAMIC) CYCLE
   
    IF (G%N_VERTS>0) THEN
      VERTS(1+IVERT:3*G%N_VERTS+IVERT) = G%VERTS(1:3*G%N_VERTS)
      IVERT = IVERT + 3*G%N_VERTS
   ENDIF
   
   IF (G%N_FACES>0) THEN
      FACES(1+IFACE:3*G%N_FACES + IFACE) = G%FACES(1:3*G%N_FACES)+OFFSET
      IFACE = IFACE + 3*G%N_FACES

      SURF_IDS(1+ISURF:G%N_FACES+ISURF) = G%SURFS(1:G%N_FACES)
      ISURF = ISURF +   G%N_FACES
   ENDIF
   OFFSET = OFFSET + G%N_VERTS
END DO
END SUBROUTINE MERGE_GEOMS

! ------------ SUBROUTINE EXPAND_GROUPS ---------------------------------

SUBROUTINE EXPAND_GROUPS(IGEOM)

! for each geometry specifed in a &GEOM line, merge geometries referened
! by GEOM_IDS after scaling, rotating and translating

INTEGER, INTENT(IN) :: IGEOM

INTEGER :: IVERT, IFACE, J, NSUB_VERTS ,NSUB_FACES, SURF_INDEX
INTEGER, POINTER, DIMENSION(:) :: FIN,FOUT, SURFIN, SURFOUT
REAL(EB) :: M(3,3)
REAL(EB), POINTER, DIMENSION(:) :: XIN, XOUT
REAL(EB), DIMENSION(:), POINTER :: DSCALEPTR, DXYZ0PTR, DXYZPTR
TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL(), GSUB=>NULL()
REAL(EB), DIMENSION(3,3) :: GIDENTITY
REAL(EB) :: GZERO=0.0_EB


IF (IGEOM.LE.1)RETURN   
G=>GEOMETRY(IGEOM)
     
IF (G%NSUB_GEOMS.EQ.0) RETURN
      
IF (G%N_VERTS_BASE.EQ.0.OR.G%N_FACES_BASE.EQ.0) RETURN ! nothing to do if GEOM_IDS geometries are empty

GIDENTITY = RESHAPE ((/&
               1.0_EB,0.0_EB,0.0_EB,&
               0.0_EB,1.0_EB,0.0_EB,&
               0.0_EB,0.0_EB,1.0_EB &
               /),(/3,3/))

IVERT = 0
IFACE = 0
DO J = 1, G%NSUB_GEOMS
   GSUB=>GEOMETRY(G%SUB_GEOMS(J))
   NSUB_VERTS = GSUB%N_VERTS_BASE
   NSUB_FACES = GSUB%N_FACES_BASE
        
   IF (NSUB_VERTS.EQ.0.OR.NSUB_FACES.EQ.0) CYCLE

   DSCALEPTR(1:3) => G%DSCALE(1:3,J)
   CALL SETUP_TRANSFORM(DSCALEPTR,G%DAZIM(J),G%DELEV(J),GIDENTITY,GZERO,M)
     
   XIN(1:3*NSUB_VERTS) => GSUB%VERTS(1:3*NSUB_VERTS)
   XOUT(1:3*NSUB_VERTS) => G%VERTS_BASE(1+3*IVERT:3*(IVERT+NSUB_VERTS))
        
   DXYZ0PTR(1:3) => G%DXYZ0(1:3,J)
   DXYZPTR(1:3) => G%DXYZ(1:3,J)
   CALL ROTATE_VEC(M,NSUB_VERTS,DXYZ0PTR,XIN,XOUT)
   CALL TRANSLATE_VEC(DXYZPTR,NSUB_VERTS,XOUT,XOUT)
        
   ! copy and offset face indices
        
   FIN(1:3*NSUB_FACES) => GSUB%FACES(1:3*NSUB_FACES)
   FOUT(1:3*NSUB_FACES) => G%FACES(1+3*IFACE:3*(IFACE+NSUB_FACES))

   FOUT = FIN + IVERT

   ! copy surface indices
        
   SURFIN(1:NSUB_FACES) => GSUB%SURFS(1:NSUB_FACES)
   SURFOUT(1:NSUB_FACES) => G%SURFS(1+IFACE:IFACE+NSUB_FACES)
   SURFOUT = SURFIN
   
   IVERT = IVERT + NSUB_VERTS
   IFACE = IFACE + NSUB_FACES
END DO
G%N_VERTS=IVERT
G%N_FACES=IFACE
IF (G%HAS_SURF.AND.IFACE>0) THEN
   SURF_INDEX = GET_SURF_INDEX(G%SURF_ID)
   G%SURFS(1:G%N_FACES) = SURF_INDEX
ENDIF
IF(IVERT>0)G%VERTS(1:3*G%N_VERTS)=G%VERTS_BASE(1:3*G%N_VERTS)
END SUBROUTINE EXPAND_GROUPS

! ------------ SUBROUTINE OBST2GEOM ---------------------------------

SUBROUTINE OBST2GEOM
   TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
   TYPE(OBSTRUCTION_TYPE), POINTER :: OB=>NULL()
   INTEGER :: N_FACES, N_VERTS
   INTEGER :: IZERO, I, J, IOB
   
   INTEGER, DIMENSION(12,3) :: FACE_LIST
   INTEGER, DIMENSION(8,3) :: VERT_LIST
  
   DATA ((FACE_LIST(I,J),J=1,3),I=1,12) /&
      4,1,5,  4,5,8,  2,3,7,  2,7,6, &
      1,2,6,  1,6,5,  3,4,7,  4,8,7, & 
      1,3,2,  1,4,3,  5,6,7,  5,7,8/

   DATA ((VERT_LIST(I,J),J=1,3),I=1,8) /&
      1,3,5,  2,3,5,  2,4,5,  1,4,5, &
      1,3,6,  2,3,6,  2,4,6,  1,4,6 /
      
     
     
   G=>GEOMETRY(0)
   N_FACES = 12*N_OBST
   N_VERTS = 8*N_OBST
   G%N_FACES = N_FACES
   G%N_VERTS = N_VERTS
   G%N_FACES_BASE = N_FACES
   G%N_VERTS_BASE = N_VERTS
   G%NSUB_GEOMS = 0
   
   G%COMPONENT_ONLY=.FALSE.
   G%IS_DYNAMIC = .FALSE.
   G%ID = 'obst'
   G%SURF_ID = 'null'
   
   G%AZIM = 0.0_EB
   G%ELEV = 0.0_EB
   G%SCALE = 1.0_EB
   G%XYZ = 0.0_EB
   
   G%XYZ0 = 0.0_EB

   G%SCALE_BASE = G%SCALE
   G%AZIM_BASE = G%AZIM
   G%ELEV_BASE = G%ELEV
   G%XYZ_BASE = G%XYZ
      
   G%AZIM_DOT = 0.0_EB
   G%ELEV_DOT = 0.0_EB
   G%SCALE_DOT = 0.0_EB
   G%XYZ_DOT = 0.0_EB
   
   IF (N_OBST.EQ.0) RETURN

   ALLOCATE(G%FACES(3*N_FACES),STAT=IZERO)
   CALL ChkMemErr('READ_GEOM','FACES',IZERO)

   ALLOCATE(G%SURFS(N_FACES),STAT=IZERO)
   CALL ChkMemErr('READ_GEOM','SURFS',IZERO)

   ALLOCATE(G%VERTS_BASE(3*N_VERTS),STAT=IZERO)
   CALL ChkMemErr('READ_GEOM','VERTS',IZERO)

   ALLOCATE(G%VERTS(3*N_VERTS),STAT=IZERO)
   CALL ChkMemErr('READ_GEOM','VERTS',IZERO)
   
   DO IOB = 1, N_OBST
      OB=>OBSTRUCTIONS(IOB)
      
      DO I = 1, 8
         G%VERTS(3*I-2) = OB%XB(VERT_LIST(I,1))
         G%VERTS(3*I-1) = OB%XB(VERT_LIST(I,2))
         G%VERTS(3*I)   = OB%XB(VERT_LIST(I,3))
      END DO
      G%VERTS_BASE = G%VERTS
      
      DO I = 1, 12      
         G%FACES(3*I-2) = FACE_LIST(I,1) + 12*(IOB-1)
         G%FACES(3*I-1) = FACE_LIST(I,2) + 12*(IOB-1)
         G%FACES(3*I)   = FACE_LIST(I,3) + 12*(IOB-1)
      END DO

      DO I = 1, 6      
         G%SURFS(2*I-1) = OB%SURF_INDEX(I)
         G%SURFS(2*I)   = OB%SURF_INDEX(I)
      END DO
   END DO
   
END SUBROUTINE OBST2GEOM

! ------------ SUBROUTINE OUTGEOM ---------------------------------

SUBROUTINE OUTGEOM(LUNIT,IS_DYNAMIC,TIME)
   INTEGER, INTENT(IN) :: LUNIT
   REAL(EB), INTENT(IN) :: TIME
   LOGICAL, INTENT(IN) :: IS_DYNAMIC
   INTEGER :: ZERO=0
   
   INTEGER :: N_VERTS, N_FACES
   INTEGER :: I
   TYPE(GEOMETRY_TYPE), POINTER :: G=>NULL()
   INTEGER, ALLOCATABLE, DIMENSION(:) :: FACES, SURF_IDS
   REAL(EB), ALLOCATABLE, DIMENSION(:) :: VERTS
   INTEGER :: IZERO

   CALL PROCESS_GEOM(IS_DYNAMIC,TIME)  ! scale, rotate, translate GEOM vertices 

   N_VERTS=0
   N_FACES=0
   DO I = 0, N_GEOMETRY ! count vertices and faces
      G=>GEOMETRY(I)
      
      IF (G%COMPONENT_ONLY) CYCLE
      IF (G%IS_DYNAMIC.AND..NOT.IS_DYNAMIC) CYCLE
      IF (.NOT.G%IS_DYNAMIC.AND.IS_DYNAMIC) CYCLE
      N_VERTS = N_VERTS + G%N_VERTS
      N_FACES = N_FACES + G%N_FACES
   END DO
   
   IF (N_VERTS.GT.0.AND.N_FACES.GT.0) THEN
      ALLOCATE(VERTS(3*N_VERTS),STAT=IZERO)   ! create arrays to contain all vertices and faces
      CALL ChkMemErr('WRITE_GEOM_TO_SMV','VERTS',IZERO)
   
      ALLOCATE(FACES(3*N_FACES),STAT=IZERO)
      CALL ChkMemErr('WRITE_GEOM_TO_SMV','FACES',IZERO)

      ALLOCATE(SURF_IDS(N_FACES),STAT=IZERO)
      CALL ChkMemErr('WRITE_GEOM_TO_SMV','SURF_IDS',IZERO)

      CALL MERGE_GEOMS(VERTS,N_VERTS,FACES,SURF_IDS,N_FACES,IS_DYNAMIC)
   ENDIF

   IF (IS_DYNAMIC) WRITE(LUNIT)REAL(TIME,FB),ZERO
   WRITE(LUNIT) N_VERTS, N_FACES
   IF (N_VERTS>0) WRITE(LUNIT) (REAL(VERTS(I),FB), I=1,3*N_VERTS)
   IF (N_FACES>0) THEN
      WRITE(LUNIT) (FACES(I), I=1,3*N_FACES)
      WRITE(LUNIT) (SURF_IDS(I), I=1,N_FACES)
   ENDIF
   
   IF (N_VERTS.GT.0) DEALLOCATE(VERTS)
   IF (N_FACES.GT.0) THEN
      DEALLOCATE(FACES)
      DEALLOCATE(SURF_IDS)
   ENDIF
END SUBROUTINE OUTGEOM

! ------------ SUBROUTINE WRITE_GEOM ---------------------------------

SUBROUTINE WRITE_GEOM(TIME)

! output geometries to a .ge file

   REAL(EB), INTENT(IN) :: TIME
   INTEGER :: ONE=1, ZERO=0, VERSION=0

   IF (N_GEOMETRY.LE.0) RETURN

   IF (ABS(TIME-T_BEGIN).LT.TWO_EPSILON_EB) THEN
      OPEN(LU_GEOM(1),FILE=FN_GEOM(1),FORM='UNFORMATTED',STATUS='REPLACE')
      WRITE(LU_GEOM(1)) ONE
      WRITE(LU_GEOM(1)) VERSION
      WRITE(LU_GEOM(1)) ZERO ! floating point header
      WRITE(LU_GEOM(1)) ZERO ! integer header
      
      CALL OUTGEOM(LU_GEOM(1),.FALSE.,TIME) ! write out static data
      CALL OUTGEOM(LU_GEOM(1),.TRUE.,TIME) ! write out dynamic data
      CLOSE(LU_GEOM(1))
      RETURN
   ENDIF

   OPEN(LU_GEOM(1),FILE=FN_GEOM(1),FORM='UNFORMATTED',STATUS='OLD',POSITION='APPEND')
   CALL OUTGEOM(LU_GEOM(1),.TRUE.,TIME) ! write out dynamic data
   CLOSE(LU_GEOM(1))

END SUBROUTINE WRITE_GEOM

END MODULE COMPLEX_GEOMETRY
